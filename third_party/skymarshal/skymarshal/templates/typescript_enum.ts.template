// This file automatically generated by skymarshal.
// DO NOT MODIFY BY HAND!!!!
{# -- Import lcm decoder from library -- #}
import Long from "long";
import Decoder from "{{typescript_library_path}}/decoder";
import Encoder from "{{typescript_library_path}}/encoder";
import LcmEnumMsg from "{{typescript_library_path}}/enum";

{# -- Generate typescript enum, which we then wrap -- #}
enum option_t {
{% for case in enum_type.cases %}
  {{case.name}} = {{case.int_value}},
{% endfor %}
}

{# -- Generate true lcm decoder -- #}
export class {{enum_type.name}} extends LcmEnumMsg {
  ["constructor"]: typeof {{enum_type.name}}; // allow access to constructor
  public static option_t = option_t;
  private static _hash = Long.fromString("{{enum_type.hash.int_value}}", true);
  private static _packed_fingerprint?: Long;

  /** @internal */
  public static _get_packed_fingerprint(): Long {
    if ({{enum_type.name}}._packed_fingerprint === undefined) {
      {{enum_type.name}}._packed_fingerprint = {{enum_type.name}}._get_hash_recursive([]);
    }
    return {{enum_type.name}}._packed_fingerprint;
  }

  /** @internal */
  public static _get_hash_recursive(parents: any[]): Long {
    if (parents.indexOf({{enum_type.name}}) > -1) {
      return Long.fromNumber(0, true);
    }
    let tmp_hash = {{enum_type.name}}._hash;
    tmp_hash = tmp_hash.shl(1).add(tmp_hash.shru(63));
    return tmp_hash;
  }

  public decode(array: Uint8Array): {{enum_type.name}} {
    const decoder = new Decoder(
      new DataView(array.buffer, array.byteOffset, array.byteLength)
    );
    const hash = decoder.decode_hash();
    if (!hash.equals({{enum_type.name}}._get_packed_fingerprint())) {
      console.error("Hash mismatch", hash, {{enum_type.name}}._get_packed_fingerprint());
      throw new Error("Hash mismatch!");
    }
    this.decode_one(decoder);
    return this;
  }

  {# -- TS enums can't use arbitrary types, warn about int64_t -- #}
  // Recursively decode a message with the supplied decoder.
  public decode_one(decoder: Decoder): {{enum_type.name}} {
{% if enum_type.storage_type.name == "int64_t" or enum_type.storage_type.name == "uint64_t" %}
    console.warn('64-bit enums are not guaranteed to work');
{% endif %}
    this.value = decoder.decode_{{enum_type.storage_type.name}}();
    return this;
  }

  /** @internal */
  public _get_encoded_size(): number {
    return {{enum_type.storage_type.storage_size}};
  }

  public encode(): ArrayBuffer {
    const total_size = this._get_encoded_size();
    const encoder = new Encoder(total_size);
    this.encode_one(encoder);
    return encoder.view.buffer;
  }

  public encode_one(encoder: Encoder): void {
    encoder.encode_{{enum_type.storage_type.name}}(this.value);
  }

  // static constructors
{% for case in enum_type.cases %}
  static get {{case.name}}() {
    return new {{enum_type.name}}(option_t.{{case.name}});
  }
{% endfor %}

  public value: option_t;

  public get name(): string {
    return option_t[this.value];
  }
}
